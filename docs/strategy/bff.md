# Next.js를 BFF로 쓰는 전략

### BFF의 목적

Next.js(App Router)를 BFF로 두는 목적은 크게 2가지입니다.

1. **브라우저에 민감정보(토큰)를 노출하지 않고 인증을 서버에서 일관되게 통제**

- AT/RT를 HttpOnly Cookie에 보관하고, 클라이언트 JS는 토큰을 모름
- 인증 헤더/갱신/세션 만료 처리/권한 확인을 “서버 레이어(Next)”가 중앙에서 처리

2. **프론트가 필요로 하는 “화면 단위 데이터 형태”로 백엔드 API를 재구성**

- 백엔드는 도메인/리소스 단위 API를 제공
- 프론트는 “페이지/위젯/사용자 흐름” 단위로 데이터가 필요
- BFF는 이 간극을 메워서 **프론트의 복잡도를 낮추고, 화면 구현 속도를 높임**

Next BFF는 단순 프록시가 아니라
**(A) 보안 게이트 + (B) 프론트 맞춤 오케스트레이션 계층**입니다.

---

### (1) Authentication Gateway 패턴

- 인증이 필요한 모든 요청이 Next를 통과해야 함
- Next는 쿠키 기반 세션 상태를 기반으로 백엔드 호출 시 Authorization을 구성하거나, 백엔드 세션을 유지함
- 결과: 브라우저는 인증 책임에서 해방되고, 보안 사고 면적이 줄어듦

### (2) Consistent Session Control

- RT 회전, AT 재발급, 세션 만료 시 처리(로그아웃/리다이렉트/에러 포맷)를 서버에서 통일
- 클라이언트는 “인증 에러 처리” 로직이 얇아짐
  (401에서 토큰 갱신/재시도 같은 복잡성이 사라짐)

---

### (3) Next BFF의 “명확한 역할” (해야 하는 것 / 하지 말아야 하는 것)

#### Next BFF가 해야 하는 것 (Do)

1. **토큰 프록시/세션 관리의 단일 진입점**

- 토큰 갱신, 쿠키 설정, 인증 실패 공통 응답, 로그/메트릭

2. **프론트 친화적 API 설계**

- 화면 단위 aggregate endpoint
- 프론트가 자주 쓰는 형태(예: `room + me + messages`)로 정리된 응답

3. **백엔드 변화의 완충지대**

- 백엔드 리소스/스키마가 바뀌어도 프론트는 BFF 계약만 맞추면 됨
- 결과적으로 프론트 릴리즈 안정성↑, 백엔드 리팩터링 자유도↑

4. **정책/권한/가드 레이어**

- “이 사용자에게 이 화면 데이터가 보여도 되는가?”
- 단순히 백엔드 401 전달이 아니라, 프론트 UX에 맞춘 에러 분기(예: CLOSED 룸이면 특정 응답) 같은 정책을 둠

#### Next BFF가 하지 말아야 하는 것 (Don’t)

1. **도메인 비즈니스 로직의 본체가 되면 안 됨**

- BFF는 조합/정책/형변환/캐시/에러정의까지는 OK
- 하지만 “핵심 규칙” (예: 결제 정산 규칙, 채팅 상태 전이의 진실)은 백엔드 소스오브트루스

2. **무한정 많은 데이터를 내려주기**

- BFF는 “화면 초기 구동에 필요한 최소 단위”를 설계해야 함
- 그렇지 않으면 BFF가 병목(서버 비용↑, 응답 무거움↑)이 됨

---

### (4) “인증 토큰 프록시”를 전략적으로 정리

#### 목표

- 토큰을 브라우저 JS에 노출하지 않는다
- 인증/갱신/세션 만료 UX를 서버에서 일관되게 만든다
- 프론트는 “인증이 있는 API 호출”을 그냥 하면 된다 (쿠키 자동 포함)

#### 운영 원칙

- **BFF가 백엔드 호출 시 필요한 인증 컨텍스트를 구성**
  - 쿠키의 AT를 사용하거나, 필요 시 RT로 갱신 후 재시도

- **클라이언트는 인증 상태를 ‘결과로만’ 이해**
  - 성공이면 데이터, 실패면 표준 에러(예: `UNAUTHORIZED`, `SESSION_EXPIRED`)를 받음

#### 패턴의 장점

- XSS, 토큰 탈취 리스크를 구조적으로 낮춤
- 모바일 WebView/PWA에서도 토큰 저장/갱신 구현 난이도가 내려감
- 프론트 팀이 인증 세부사항에서 독립됨 (생산성↑)

---

### (5) 페이지 단위 데이터 집계(aggregation)

Aggregation은 단지 빠르게 하자는 게 아니라, **프론트의 API 사용성을 제품처럼 만드는 것**입니다.

#### 왜 필요한가

- 백엔드 API는 대개 “리소스 중심”
- 프론트 화면은 “사용자 작업 중심”
- 화면은 여러 리소스를 동시에 요구하고, 그 결합 규칙이 UI/UX에 종속됨
  → 이 결합 규칙을 클라이언트에 흩뿌리면 화면마다 중복, 오류, 분기 폭발이 생김

#### BFF aggregation이 해결하는 것

- 프론트의 “데이터 조립 책임” 제거
- 화면 초기 상태를 **서버에서 정의된 계약**으로 제공
- “이 화면을 띄우는 최소 데이터셋”이 표준화됨
  → 신규 플랫폼(앱/웹/관리자)이 생겨도 활용 가능

---

### (6) Next(BFF) API 설계 원칙

#### (1) Endpoint 네이밍: “페이지/유스케이스” 단위로

- `/api/bff/chat-room?id=123` 같은 형태는 방향이 맞음
- 더 명확히 하려면
  - `/api/bff/chats/:id/boot` (채팅 상세 첫 진입 부트스트랩)
  - `/api/bff/chats/list/boot` (리스트 화면 초기 진입)

#### (2) 응답 스키마는 “프론트 계약”으로 고정

- 백엔드 스키마를 그대로 패스스루하지 말고,
- 프론트가 필요로 하는 필드만
- 버전이 필요하면 `v1/v2` 또는 `schemaVersion` 명시

#### (3) 에러 포맷 표준화 (고려)

- BFF는 에러를 그대로 전달하지 말고 “프론트 UX 단위”로 정리
- 예:
  - `SESSION_EXPIRED` → 로그인 유도
  - `CHAT_ROOM_CLOSED` → 읽기 전용 뷰
  - `FORBIDDEN` → 접근 불가 안내

#### (4) 캐시/중복 호출 제어는 BFF에서

- “동일한 유저/동일 페이지 부트 요청”이 짧은 시간에 여러 번 들어올 수 있음
- BFF에서 짧은 TTL 캐시/요청 coalescing을 걸면 서버 비용과 백엔드 부하를 낮출 수 있음
  (이건 성능 목적도 있지만, 더 큰 건 **안정성/비용 통제**)

---

### (7) BFF를 “플랫폼”으로 만들기 위한 체크리스트

### 관측/로깅 (필수)

- 요청 단위 correlation id (클라→BFF→백엔드 추적)
- BFF 내부에서 호출한 백엔드 endpoint별 latency 기록
- 사용자 단위/페이지 단위 성공률, 401/403 비율

### 배포/호환성

- BFF는 프론트 릴리즈와 강하게 결합되기 쉬움
  → “계약 우선(Contract First)”로 변경 관리
- 백엔드 변경이 들어오면 BFF가 완충 역할을 해야 함

### 보안

- 쿠키: SameSite/secure/도메인 정책 엄격히
- CSRF 방어(특히 state-changing API)
- 서버에서만 토큰 취급(로그에 토큰/PII 남기지 않기)

---
