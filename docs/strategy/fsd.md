오케이, 이제 진짜 의도 정확히 이해했어요.
**“요약/인용/후기 추가”가 아니라**,
👉 **카카오페이 FSD 적용기에서 드러난 사고방식·판단 기준·실전 규칙을 흡수해서
지금 쓰고 있는 FSD 전략 자체를 다시 재구성**하는 거죠.

아래는 **블로그 글을 ‘참고 사례’로 언급하지 않고**,
마치 **이 프로젝트의 FSD 전략이 그 경험을 내재화해서 나온 것처럼**
자연스럽게 재작성한 버전입니다.

톤은 **아키텍처 가이드 / 내부 설계 문서**,
지금 주신 `3. 폴더 구조 (FSD 기반)` 섹션을 **확장·재구성**하는 방식이에요.

---

# 3. 폴더 구조 (FSD 기반)

본 프로젝트는 **Feature-Sliced Design(FSD)** 을 기반으로 폴더 구조를 설계한다.
이는 단순한 디렉토리 정리가 아니라,
**“이 코드는 어디에 있어야 하는가?”라는 질문에 구조로 답하기 위한 선택**이다.

프로젝트 규모가 커질수록 프론트엔드에서 반복적으로 발생하는 문제는 다음으로 수렴한다.

- 기능 로직이 UI / Hook / API 폴더로 흩어지며 응집도가 붕괴됨
- 공통과 전용 코드의 경계가 모호해짐
- 코드 수정 시 영향 범위를 예측하기 어려워짐
- 특정 도메인을 잘 아는 작업자에게 의존도가 집중됨

이러한 문제는 개별 개발자의 주의나 컨벤션만으로는 해결되지 않는다.
**구조 자체가 코드의 책임과 재사용 범위를 강제하지 않기 때문**이다.

FSD는 기능(Feature)과 도메인(Entity)을 기준으로 코드를 묶고,
레이어 간 **단방향 의존성 규칙**을 통해
확장 이후에도 구조적 일관성을 유지하도록 설계된 아키텍처다.

---

## 3.1 FSD 설계의 핵심 목표

본 프로젝트에서 FSD를 도입하는 목적은 다음 세 가지로 명확하다.

1. **코드 위치의 명확성**
   - “이 코드는 어디에 둬야 하는가?”에 대한 구조적 답 제공

2. **재사용 범위의 통제**
   - 페이지 전용 / 기능 전용 / 도메인 공용 코드를 명확히 분리

3. **변경 영향 범위의 예측 가능성**
   - 코드 수정 시 어디까지 영향을 주는지 구조만 보고 판단 가능

---

## 3.2 App Router 환경에서의 FSD 재해석

### 3.2.1 `app/` 디렉토리의 역할 재정의 (Entry Layer)

Next.js App Router 환경에서 `app/`은
**FSD의 `pages` 레이어와 동일한 책임을 가지지 않는다.**

`app/`은 다음 역할로 **엄격히 제한**한다.

- 라우팅 엔트리
- 화면 조합(Composition)
- Server / Client Boundary 명시

즉, `app/`은 **도메인이나 기능을 소유하지 않는 Entry Layer**다.

#### 허용되는 책임

- `page.tsx`, `layout.tsx`, `loading.tsx` 등 라우팅 엔트리
- `widgets / features / entities`를 가져와 화면 구성
- route segment 수준의 조합
- (선택) BFF 역할의 Route Handler (`app/api/**/route.ts`)

#### 금지되는 책임

- 도메인 모델 정의
- 상태 관리 로직
- 비즈니스 규칙(정책, 계산, 분기)
- 재사용 목적의 UI / util

> 원칙:
> `page.tsx`가 복잡해지는 순간,
> 그 코드는 **잘못된 위치에 있다**.

---

## 3.3 레이어 구조와 책임 기준

레이어는 **“얼마나 넓게 재사용되는가”** 를 기준으로 나눈다.

### 레이어 정의

- **`widgets/`**
  - 페이지를 구성하는 **섹션 단위 UI**
  - 여러 feature / entity를 조합
  - 독립적으로 동작 가능한 화면 블록

- **`features/`**
  - 사용자의 **행동/시나리오 단위**
  - mutation, 트리거, 후처리 흐름
  - UI + 상태 + API가 하나의 기능으로 응집됨

- **`entities/`**
  - 비즈니스 **도메인 자체**
  - 타입, 모델, 조회(query), 도메인 UI
  - 여러 feature에서 재사용됨

- **`shared/`**
  - 도메인과 무관한 공통 요소
  - primitive UI, infra, lib, config

### 판단 예시

- “전문가 리스트 섹션” → `widgets`
- “채팅 요청하기 버튼 + mutation” → `features`
- “expert 도메인 타입 / 조회 API” → `entities`
- “Button / Modal / fetcher” → `shared`

---

## 3.4 Slice 설계의 핵심 원칙: 응집도 우선

Slice는 **비즈니스 도메인 기준으로 코드를 묶기 위한 단위**다.

중요한 규칙은 다음과 같다.

- 같은 레이어 내 Slice 간 **직접 의존 금지**
- Slice 내부에서는 UI / model / api가 함께 존재 가능
- “이 코드가 이 도메인에 속하는가?”가 판단 기준

이를 통해 얻는 효과는 명확하다.

- 관련 코드가 한 곳에 모인다 (응집도 ↑)
- 다른 도메인의 변경이 전파되지 않는다 (결합도 ↓)
- 기능 단위 사고가 강제된다

---

## 3.5 API 코드 위치 결정 규칙 (가장 중요한 판단 기준)

API 코드는 **기술적 성격이 아니라 재사용 범위**로 위치가 결정된다.

### 결정 기준

1. **특정 페이지(또는 위젯)에서만 사용하는 API**
   - → 해당 Slice 내부 `api/`

2. **같은 기능/시나리오 내 여러 화면에서 사용하는 API**
   - → `features/[slice]/api`

3. **여러 기능/페이지에서 공통으로 사용하는 도메인 API**
   - → `entities/[domain]/api`

이 규칙을 따르면 다음 문제가 사라진다.

- Entity 레이어의 비대화
- 페이지 전용 API의 무분별한 전역화
- “이 API가 공통인지 아닌지”에 대한 논쟁

---

## 3.6 Public Interface 강제 (캡슐화 규칙)

Auth / Chat / Payment 같은 도메인은
정책·권한·상태 전이 등 **변경 가능성이 높은 규칙**을 포함한다.

이를 외부 레이어에서 직접 참조하면:

- 규칙 중복
- 구조 전반으로 변경 전파
- 도메인 경계 붕괴

따라서 모든 Slice는 **명시적인 Public Interface(`index.ts`)만 노출**한다.

### 규칙

- 외부 레이어는 `index.ts`만 import
- 내부 경로 직접 접근 금지
- 무엇을 외부에 공개할지 Slice가 통제

이 규칙은
**“구조적 안정성은 캡슐화에서 나온다”** 는 경험적 결론에 기반한다.

---

## 3.7 상향식(Bottom-Up) 확장 전략

FSD는 처음부터 완벽히 설계하지 않는다.
**재사용 범위가 넓어질 때만 레이어를 상승시킨다.**

### 이동 규칙

1. 처음에는 `features` 또는 `pages(entry)`에 둔다
2. 여러 feature에서 쓰이면 `entities`로 이동
3. 전역적으로 쓰이면 `shared`로 이동

이 규칙을 통해 팀원은 항상 같은 질문을 하게 된다.

> “이 코드는 지금 어디까지 재사용되고 있는가?”

그리고 그 질문이 곧 **정답**이 된다.

---

## 3.8 이 전략이 보장하는 것

- 코드 위치에 대한 팀 내 논쟁 감소
- 신규 작업자의 구조 이해 속도 향상
- 변경 영향 범위의 구조적 예측 가능성
- 기능 확장 시 구조 붕괴 방지

FSD는 단순히 코드를 나누는 규칙이 아니라,
**개발자가 구조를 신뢰할 수 있게 만드는 장치**다.
