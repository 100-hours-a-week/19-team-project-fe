# 19-team-project-fe

## 기술 스택 정리

| 영역 | 기술 |
| --- | --- |
| Framework | Next.js (App Router) |
| Library | React |
| Language | TypeScript |
| Rendering | SSR / RSC / CSR Hybrid |
| Client State | Zustand |
| Server State | TanStack Query |
| Styling | TailwindCSS, shadcn/ui |
| Build (Dev) | Turbopack |
| Build (Prod) | Webpack |
| Transpiler | SWC |
| Package Manager | pnpm |
| Architecture | Feature-Sliced Design (FSD) |
| PWA | PWA 지원 |
| Service Worker | Static Asset Cache Only |
| Target Environment | Mobile Web, AppView |


## <mark> 0. 서비스 특성 정리 </mark>

본 서비스는 다음과 같은 특성을 가진다.

- 모바일 사용 비중이 높은 **PWA / AppView 중심 서비스**
- **비로그인 상태에서도 검색·추천·프리뷰 가능**
- 행동 시점(채팅 요청)에 로그인 전환이 발생
- 로그인 이후
    - 실시간 채팅
    - 대화 기반 데이터 저장
    - 레포트 생성 및 조회
- 사용자 상태(비로그인 / 로그인 / 인증 완료 / 데이터 유무)에 따른 **화면 분기 다수**

**기술 스택은 단순 CRUD 웹이 아닌 “상태 분기 + 초기 진입 UX + 서버/클라이언트 역할 분리”를 해결하는 데 초점을 둔다.**

---

# <mark> 1. Core Stack </mark>

## 1.1 React + TypeScript

### 1.1.1 React 기반 UI 모델 정리

본 프로젝트는 상태 변화에 따라 UI가 빈번하게 전환되는 서비스 구조를 가진다.

이에 따라 UI 계층은 상태 변화 → 화면 반영 흐름이 명확한 모델을 전제로 설계된다.

### 프레임워크 비교 관점

| 구분 | React | Vue | Angular | Svelte |
| --- | --- | --- | --- | --- |
| UI 패러다임 | 컴포넌트 기반 | 컴포넌트 기반 | 컴포넌트 기반 | 컴파일 기반 |
| 상태 관리 | 외부 조합 | 자체 + 외부 | RxJS 중심 | 컴파일 결과 |
| 메타 프레임워크 | Next.js | Nuxt | Angular Universal | SvelteKit |
| SSR/RSC 대응 | 매우 성숙 | 성숙 | 공식 지원 | 성숙 |
| 대규모 사례 | 풍부 | 풍부 | 엔터프라이즈 중심 | 상대적으로 적음 |

### 1️⃣ 상태 변화 중심 UI 모델과의 적합성

React는 상태 변경에 따라 UI를 재계산하는 단방향 데이터 흐름을 기본 모델로 사용한다.

이 구조는 다음과 같은 서비스 흐름을 명확하게 표현하는 데 적합하다.

- 인증 여부에 따른 UI 분기
- 검색 조건 변경에 따른 리스트 갱신
- 채팅 진행 상태 변화
- 레포트 생성/조회 상태 전환

상태 변화가 많고, 동일 화면 내에서도 UI 책임이 자주 분기되는 서비스 특성상 단방향 데이터 흐름은 UI 동작을 예측 가능하게 유지하는 데 유리하다.

### 2️⃣  검증된 생태계 기반 조합

React 생태계는 각 관심사별로 성숙한 도구를 조합할 수 있다.

- 클라이언트 전역 상태: Zustand
- 서버 상태 관리: TanStack Query
- UI 구성: shadcn/ui (Radix UI 기반)

이는 상태, 데이터, UI 책임을 명확히 분리한 구조를 구성하는 데 적합하다.

## 1.2 TypeScript 기반 정적 타입 환경

### 1.2.1 TypeScript 도입 배경

본 프로젝트는 분기 조건과 상태 전환이 많은 구조를 가지며, 런타임 오류보다 **개발 단계에서의 안정성 확보**가 중요하다.

| 구분 | JavaScript | TypeScript |
| --- | --- | --- |
| 타입 시스템 | 동적 | 정적 |
| 오류 발견 시점 | 런타임 | 컴파일 타임 |
| 대규모 코드 관리 | 경험 의존 | 타입 기반 |
| API 변경 추적 | 수동 | 타입 에러로 즉시 감지 |

---

### 1️⃣ 분기 많은 로직에서의 안정성

로그인 여부, 인증 상태, 데이터 존재 여부에 따라 UI와 로직 분기가 빈번하게 발생한다.

TypeScript는 `null`, `undefined`, 잘못된 필드 접근과 같은 오류를 컴파일 단계에서 사전에 차단하여 안정적인 분기 처리를 가능하게 한다.

### 2️⃣ 서버 데이터와 UI 간 계약 명확화

서버 API 응답 구조는 개발 과정에서 지속적으로 변경될 수 있다.

TypeScript를 사용하면 API 응답 타입을 기준으로 UI를 구성할 수 있으며, 응답 구조 변경 시 영향 범위를 즉시 파악할 수 있다. 이는 TanStack Query 기반 서버 상태 관리 전략과 자연스럽게 결합된다.

### 3️⃣ 유지보수 비용 및 운영 리스크 감소

TypeScript는 오류를 사용자 환경이 아닌 개발 단계에서 노출시킴으로써, 디버깅 비용과 운영 리스크를 줄이는 역할을 한다. 이는 장기적인 유지보수 관점에서 중요한 선택이다.

## 1.3 Next.js

### 1.3.1 React SPA 단독 구성의 한계

React + Vite 기반 SPA는 개발 경험과 번들 성능 측면에서 강점이 있으나 다음과 같은 구조적 한계를 느꼈다.

- 초기 진입 시 HTML 단계에서 화면을 구성할 수 없으며, JavaScript 로드 이후에야 렌더링이 가능
- 인증 여부 판단이 클라이언트 로직 실행 이후에 이루어져, 보호 페이지 제어가 런타임 분기에 의존
- 메타데이터 관리, 라우팅 제어, 프리렌더링을 위해 다수의 외부 라이브러리와 추가 설정이 필요
- 공개 페이지와 로그인 이후 페이지가 동일한 애플리케이션 구조 내에 존재하여, 역할과 책임의 분리가 코드 레벨에서 명확하지 않음

이러한 특성으로 인해 SPA 단독 구성은 비로그인 상태의 콘텐츠 탐색 → 인증 전환 → 애플리케이션 사용이라는
서비스 흐름을 구조적으로 표현하는 데 한계를 가진다.

### 1.3.2 Next.js 선정 이유

### 1️⃣  초기 진입 UX 및 체감 성능 개선

본 서비스는 모바일 사용 비중이 높으며, PWA 및 AppView 환경에서 주로 사용된다.
이러한 환경에서는 초기 로딩 지연이 곧 사용자 이탈로 이어질 가능성이 크다.

Next.js는 서버 환경에서 HTML을 생성하는 렌더링 전략을 통해 메인 페이지, 검색 결과, 추천 리스트와 같은 핵심 콘텐츠를 초기 응답 단계에서 제공할 수 있다. 이를 통해 JavaScript 실행 이전에도 의미 있는 콘텐츠가 화면에 노출되며, 클라이언트 단 렌더링만 사용하는 SPA 대비 초기 진입 시 체감 성능을 개선할 수 있다.

### 2️⃣ 페이지 진입 단계에서의 렌더링 및 분기 처리

Next.js(App Router)는 페이지 진입 시점에 서버 환경에서 렌더링과 접근 제어 로직을 함께 수행할 수 있는 구조를 제공한다. 이를 통해 비로그인 사용자에게는 공개 페이지를 그대로 제공하고, 채팅 요청과 같은 특정 사용자 행동이 발생하는 시점에만 인증 및 권한 검사를 수행하는 흐름을 설계할 수 있다. 이러한 분기는 페이지 및 레이아웃 단위로 명확히 표현된다.

이는 인증 관련 분기 로직이 개별 UI 컴포넌트에 분산되는 것을 방지하고, 코드 구조를 실제 서비스 플로우
(비로그인 탐색 → 인증 → 기능 사용)와 일치시키는 데 기여한다.

### 3️⃣ **메타데이터·라우팅·프리렌더링의 구조적 통합**

Next.js(App Router)는 파일 기반 라우팅을 중심으로 렌더링 전략(SSR/SSG), 메타데이터 정의, 데이터 패칭을
페이지 및 레이아웃 단위의 단일 구조로 통합한다. 이를 통해 메타데이터와 렌더링 방식이 각 페이지의 역할과 함께 선언적으로 관리되며, 프리렌더링 또한 별도의 도구나 복잡한 빌드 구성 없이 프레임워크의 기본 동작으로 자연스럽게 적용된다.

이러한 통합 구조는 라우팅, SEO, 렌더링 전략 간의 결합도를 낮추고, 애플리케이션 전반의 설정 복잡도를 줄일 수 있다.

### 4️⃣ 공개 영역과 앱 영역의 역할 분리

Next.js의 파일 기반 라우팅과 App Router 구조는 페이지 및 레이아웃 단위의 명확한 책임 분리를 가능하게 한다. 이를 통해 서비스는 다음과 같은 영역 구성을 갖는다.

- 공개 영역: 서비스 소개, 검색/추천 프리뷰, 온보딩
- 인증 영역: 채팅, 레포트, 마이페이지

이러한 구조는 공개 페이지와 애플리케이션 기능을 물리적으로 분리된 라우팅 트리로 관리할 수 있게 하며,
그 결과 다음과 같은 이점을 제공한다.

- 사용자 흐름이 코드 구조에 그대로 반영되어 이해도가 높아진다
- 유지보수 시 기능 단위의 책임 범위가 명확해진다
- 추후 기능 확장이나 접근 정책 변경에도 구조적 안정성을 유지할 수 있다

### 5️⃣ SEO를 “부가 효과”가 아닌 “구조적 이점”으로 확보

본 서비스의 핵심 기능은 로그인 이후에 제공되지만, 다음과 같은 페이지는 비로그인 상태에서도 접근 가능하도록 설계되어 있다.

- 메인 페이지(검색/추천 프리뷰)
- 온보딩 및 서비스 설명 페이지

이러한 페이지는 사용자 유입과 초기 탐색 단계에서 중요한 역할을 하며, 초기 콘텐츠 노출과 검색 엔진 인덱싱이 특히 중요하다.

Next.js를 사용함으로써 서버 환경에서 생성된 HTML을 기반으로 페이지를 제공할 수 있으며, 페이지 단위의 메타데이터 관리와 검색 엔진 크롤러 친화적인 구조를 별도의 복잡한 설정 없이 기본적으로 확보할 수 있다.

### 6️⃣ BFF 역할을 겸한 서버 사이드 확장성

Next.js는 UI 렌더링 프레임워크에 그치지 않고, API Routes 및 App Router 기반의 서버 실행 환경을 함께 제공한다. **Backend for Frontend(BFF) 계층으로 경량 활용**하여, 프론트엔드와 백엔드 간의 결합도를 낮추고 페이지 단위의 데이터 흐름을 단순화한다.

구체적으로 Next.js 서버 레이어는 다음과 같은 역할을 수행한다.

- 인증 토큰을 브라우저에 직접 노출하지 않고, 서버에서 관리 및 전달하는 **인증 토큰 프록시**
- 한 페이지에서 필요한 다수의 백엔드 API 호출을 서버 환경에서 병렬로 집계하여 제공하는 **페이지 단위 데이터 집계**
- SSR 과정에서 필요한 데이터를 사전에 준비하여, 초기 렌더링 단계에서 완성된 HTML을 제공하는 **서버사이드 데이터 패칭**

이를 통해 클라이언트는 단일 엔드포인트를 통해 화면에 필요한 데이터를 전달받을 수 있으며,

프론트엔드 코드는 데이터 호출 및 인증 처리 로직이 아닌 **렌더링과 사용자 인터랙션에 집중**할 수 있다.

또한 이러한 구조는 백엔드 API 변경이나 인증 정책 변화가 발생하더라도, 프론트엔드 전반에 영향을 주지 않고 Next.js 서버 계층에서 변경을 흡수할 수 있는 완충 지대를 제공한다.

# <mark> 2. 상태 관리 전략 </mark>

본 프로젝트에서는 **상태가 가지는 책임과 수명 주기(lifecycle)가 서로 다르다는 점**을 기준으로

상태를 성격에 따라 명확히 분리하여 관리한다. 이를 통해 상태의 역할 혼합을 방지하고, 

각 상태가 가장 잘 다뤄질 수 있는 도구를 선택한다.

- **클라이언트 전역 상태** → Zustand
- **서버 상태(비동기 데이터)** → TanStack Query

## 2.1 전역 상태 관리 – Zustand

### 비교 검토

| 항목 | Redux / RTK | Recoil | Jotai | Zustand |
| --- | --- | --- | --- | --- |
| 보일러플레이트 | 많음 | 적음 | 적음 | 매우 적음 |
| 전역 구조 | 명시적 트리 | Atom 기반 | Atom 기반 | 자유로운 스토어 |
| 러닝 커브 | 높음 | 중간 | 낮음 | 낮음 |
| 성능 제어 | Selector 필요 | 자동 분리 | 자동 분리 | 선택적 구독 |
| SSR 연동 | 설정 필요 | 제한적 | 제한적 | 단순 |
| 번들 크기 | 큼 | 중간 | 작음 | 매우 작음 |

### Zustand 선택 이유

### 1️⃣ 전역 상태의 책임이 명확한 서비스 구조

본 서비스에서 전역 상태가 필요한 영역은 대부분 **UI 동작 및 사용자 세션 관리**에 국한된다.

이러한 상태는 Redux와 같은 엄격한 전역 상태 트리로 관리할 필요가 없으며,

Zustand의 단순한 스토어 모델이 오히려 책임을 명확히 드러낸다.

### 2️⃣ 필요한 상태만 구독하는 구조

Zustand는 상태 전체가 아닌 필요한 값만 선택적으로 구독할 수 있다.

```tsx
const isLoggedIn = useAuthStore(state => state.isLoggedIn);
```

이 방식은 불필요한 리렌더링을 방지하며, UI 규모가 커질수록 성능을 예측하기 쉬운 구조를 만든다.

### 3️⃣ Next.js(App Router) 환경과의 궁합

Next.js 환경에서는 서버 컴포넌트와 클라이언트 컴포넌트의 경계가 명확하다.

Zustand는 클라이언트 컴포넌트에서만 사용되며, 서버 렌더링 과정에 불필요하게 개입하지 않는다.

이는 “클라이언트 전용 상태”라는 역할을 명확히 유지하는 데 유리하다.

### 4️⃣ 보일러플레이트 최소화

Redux 계열은 구조가 명확한 대신, 상태가 단순한 경우에도 Action, Reducer, Slice 등의 코드가 요구된다.

Zustand는 상태 선언과 변경 로직이 간결하여 UI 중심의 전역 상태 관리에 더 적합하다.

### Zustand 사용 원칙

> Zustand는 서버 상태를 관리하지 않는다.
> 
> 
> API 응답, 캐시, 비동기 데이터는 Zustand에 저장하지 않는다.
> 
- 상태 책임 혼합 방지
- 디버깅 난이도 감소
- 서버 상태 관리 라이브러리와의 충돌 방지

### 역할 정의

Zustand는 클라이언트에만 존재하며 서버와 직접 동기화되지 않는 상태를 관리한다.

해당 상태들은 다음과 같은 공통된 특징을 가진다.

- 서버 데이터가 아님
- 새로고침 시 초기화되어도 무방
- UI 동작과 직접적으로 연결됨

### 관리 대상 예시

- 로그인 여부
- 사용자 세션 정보 (토큰, 사용자 식별자 등)
- UI 상태
    - 모달 열림/닫힘
    - 토스트 메시지
    - 전역 로딩 상태
    - UI 토글 상태

## 2.2 서버 상태 관리 – TanStack Query

### 비교 검토

| 항목 | SWR | TanStack Query |
| --- | --- | --- |
| 주 사용 목적 | 데이터 읽기 | 읽기 + 쓰기 |
| Mutation 지원 | 제한적 | 강력 |
| 캐시 제어 | 단순 | 세밀 |
| 조건부 패칭 | 코드 기반 | 옵션 기반 |
| SSR 연동 | 가능 | 공식 지원 |
| DevTools | 없음 | 제공 |
| 복잡한 플로우 | 제한적 | 적합 |

---

### TanStack Query 선택 이유

### 1️⃣ 서버 상태의 수명 주기를 명확히 관리

본 서비스의 서버 데이터는 다음과 같은 흐름을 반복한다.

- 조회 → 변경 → 캐시 무효화 → 재요청 → UI 반영

TanStack Query는 이 흐름을

`useQuery`, `useMutation`, `invalidateQueries`로 **하나의 일관된 모델**로 관리할 수 있다.

---

### 2️⃣ 조건부 패칭과 분기 처리에 적합

로그인 여부, 파라미터 존재 여부 등 조건에 따라 요청 여부가 결정되는 경우가 많다.

TanStack Query의 `enabled` 옵션은 이러한 조건을 **선언적으로 표현**할 수 있게 해준다.

```tsx
useQuery({
  queryKey: ['report', id],
  queryFn: fetchReport,
  enabled: !!id && isLoggedIn,
});
```

### 3️⃣ Mutation 이후 상태 동기화가 핵심인 서비스 구조

채팅 요청, 메시지 전송, 레포트 생성과 같은 동작 이후에는 기존 데이터 무효화와 최신 데이터 재요청이 자연스럽게 이어져야 한다. TanStack Query는 Mutation 성공 시점에 갱신할 캐시를 명확히 지정할 수 있어 이 흐름에 적합하다.

### 4️⃣ SSR + CSR 하이브리드 환경 대응

Next.js 환경에서는

- 초기 렌더링 시 서버에서 데이터 패칭
- 이후 클라이언트에서 캐시 재사용

이 흐름이 중요하다. TanStack Query는 SSR 시 prefetch와 CSR에서 hydrate가 가능한 구조를 제공하여

하이브리드 렌더링 전략과 자연스럽게 결합된다.

### TanStack Query 사용 원칙

> TanStack Query를 서버 상태의 단일 진실 공급원(Single Source of Truth)으로 사용한다.
> 
> 
> 동일 데이터를 Zustand나 local state에 중복 저장하지 않는다.
> 
- 상태 불일치 방지
- 캐시 관리 단순화
- 디버깅 비용 감소

### 역할 정의

TanStack Query는 서버와 동기화되는 모든 비동기 상태를 관리한다.

이 상태들은 다음과 같은 특성을 가진다.

- 서버 요청을 통해 생성됨
- 캐시와 동기화가 필요함
- 수명 주기가 명확함

### 관리 대상 예시

- 검색 결과
- 추천 리스트
- 채팅 데이터
- 레포트 조회 / 생성
- 무한 스크롤 데이터

# <mark> 3. 스타일링 전략 </mark>

## 3.1 Styling – TailwindCSS + shadcn/ui 선정 이유

### 3.1.1 스타일링 방식 검토 배경

본 프로젝트는 다음과 같은 UI 특성을 가진다.

- 컴포넌트 단위 UI 구성
- 상태 변화에 따른 조건부 스타일링 빈번
- 모바일 / PWA 환경 중심

이에 따라 스타일링 방식은 단순한 CSS 작성 방식의 선택이 아니라,

다음 요소를 함께 고려하는 ****아키텍처적 결정으로 판단하였다.

- 렌더링 성능
- 유지보수성
- 컴포넌트 구조와의 결합 방식
- 디자인 시스템 확장성

### 3.1.2 스타일링 방식 비교

| 구분 | CSS / SCSS | CSS-in-JS (Emotion, styled-components) | TailwindCSS |
| --- | --- | --- | --- |
| 스타일 생성 시점 | 빌드 타임 | 런타임 | 빌드 타임 |
| 런타임 오버헤드 | 없음 | 있음 | 없음 |
| 컴포넌트 결합도 | 낮음 | 높음 | 중간 |
| 조건부 스타일링 | 제한적 | 매우 유연 | 유연 |
| 디자인 일관성 | 규칙 의존 | 컴포넌트 의존 | 설정 기반 |
| SSR / RSC 친화성 | 매우 높음 | 이슈 가능 | 매우 높음 |
| Next.js 호환성 | 높음 | ~~이슈 사례 존재~~ | 공식 권장 |
| 번들 크기 영향 | 낮음 | 증가 | 낮음 |

### 3.1.3 TailwindCSS를 선택한 이유

### 1️⃣ 정적 CSS 기반 렌더링 성능

TailwindCSS는 **빌드 타임에 실제 사용되는 유틸리티 클래스만 생성**한다.

- 런타임 스타일 생성 없음
- 추가 JavaScript 실행 없음
- 스타일 계산 비용 최소화

이는 초기 렌더링 성능과 모바일 / PWA 환경에서의 체감 성능 측면에서

중요한 이점을 제공한다.

### 2️⃣ 컴포넌트 중심 개발 구조와의 결합

TailwindCSS는 스타일 정의가 컴포넌트 코드와 물리적으로 가까이 위치한다.

- 스타일과 UI 책임이 분리되지 않음
- 컴포넌트 삭제 시 관련 스타일도 함께 제거
- 사용되지 않는 스타일 누적 방지

이는 React 기반 컴포넌트 구조에서

유지보수성과 변경 추적성을 향상시키는 방향으로 작용한다.

### 3️⃣ 조건부 스타일링의 명확한 표현

본 서비스는 다음과 같은 상태 변화가 빈번하다.

- 선택 / 비선택
- 활성 / 비활성
- 로딩 / 에러 / 완료 상태

TailwindCSS는 조건부 클래스 조합을 통해 UI 상태와 스타일의 관계를 JSX 레벨에서 명확하게 표현할 수 있다.

이는 복잡한 UI 상태에서도 스타일 적용 흐름을 쉽게 추적할 수 있도록 한다.

### 4️⃣ Next.js 기반 렌더링 환경과의 구조적 궁합

TailwindCSS는 다음과 같은 렌더링 환경에서 추가 설정 없이 안정적으로 동작한다.

- React Server Component
- SSR / SSG / ISR
- 스트리밍 렌더링

Next.js 공식 문서에서도 권장되는 조합이며, 서버 렌더링 환경에서 발생할 수 있는 스타일 불일치 문제를 최소화한다.

### 3.1.4 shadcn/ui를 함께 사용하는 이유

### 1️⃣ 라이브러리가 아닌 “컴포넌트 소스” 제공

shadcn/ui는 npm 패키지 형태의 블랙박스 UI 라이브러리가 아니라,

필요한 컴포넌트를 **소스 코드 형태로 프로젝트에 직접 포함**하는 방식을 취한다.

- 컴포넌트 로직과 스타일에 대한 완전한 소유권 확보
- 프로젝트 요구사항에 맞는 자유로운 수정 가능
- 불필요한 의존성 증가 방지

이는 장기적인 유지보수와 디자인 커스터마이징 측면에서 유리하다.

## 3.2 TailwindCSS 단점에 대한 대응 전략

TailwindCSS의 단점으로 지적되는 부분은 다음과 같다.

- 클래스 길이 증가
- JSX 가독성 저하
- 중복 클래스 발생 가능성

본 프로젝트에서는 다음과 같은 전략으로 이를 관리한다.

### 1️⃣ `cva`, `tailwind-variants` 활용

- 공통 컴포넌트의 스타일 변형을 선언적으로 관리
- 클래스 조합 로직을 컴포넌트 외부로 분리
- 상태별 스타일 정의의 중복 최소화

### 2️⃣ 공통 컴포넌트 추상화

- 버튼, 입력, 카드 등 반복적으로 사용되는 UI는 공통 컴포넌트로 관리
- 페이지 레벨에서의 복잡한 클래스 조합 사용 제한
- 스타일 변경 범위를 컴포넌트 단위로 국한

### 3️⃣ 클래스 난립 방지 원칙 수립

- 복잡한 UI는 반드시 컴포넌트 단위로 분리
- 페이지 단에서 긴 클래스 조합 직접 작성 금지
- 새로운 스타일 패턴 도입 시 공통 컴포넌트 적용 여부 우선 검토

# <mark> 4. 빌드 & 개발 환경 </mark> 

## 4.1 Build & Development Environment

### 4.1.1 빌드 환경 설계 배경

본 프로젝트는 Next.js(App Router)를 코어 프레임워크로 사용하며, 다음 요구사항을 동시에 만족해야 한다.

- 빠른 개발 피드백 루프 (DX)
- SSR / RSC / PWA 환경 안정성
- 예측 가능한 프로덕션 빌드 결과
- 장기 유지보수 및 배포 안정성

이에 따라 개발 환경과 프로덕션 환경을 동일하게 가져가기보다,

각 환경의 목적에 맞춰 ****빌드 도구를 분리하는 전략을 선택하였다.

### 4.1.2 최종 선택한 빌드 구성

| 구분 | 도구 |
| --- | --- |
| 트랜스파일러 | **SWC** |
| 개발 환경 번들러 | **Turbopack** |
| 프로덕션 번들러 | **Webpack** |

### 4.1.3 트랜스파일러 정리

### 비교 대상

| 항목 | Babel | esbuild | SWC |
| --- | --- | --- | --- |
| 구현 언어 | JavaScript | Go | Rust |
| 속도 | 느림 | 매우 빠름 | 매우 빠름 |
| 멀티코어 활용 | 제한적 | 제한적 | 적극적 |
| Next.js 기본 채택 | ❌ | ❌ | ✅ |
| RSC/App Router 지원 | 제한적 | 제한적 | 완전 지원 |

SWC는 Next.js에서 기본 트랜스파일러로 사용되며, 프로젝트 전반의 코드 변환을 담당한다.

TypeScript, JSX, 최신 ECMAScript 문법뿐 아니라 React Server Component와 App Router에 필요한 변환을 별도의 설정 없이 안정적으로 처리한다.

Rust 기반 구현으로 인해 컴파일 속도가 빠르고, 멀티코어 환경에서도 효율적으로 동작한다는 점에서 개발 환경과 CI 환경 모두에 적합하다. 

본 프로젝트에서는 SWC를 선택한 도구라기보다, Next.js 내부 컴파일 계층으로 인식하고 그대로 활용한다.

### 4.1.4 개발 환경 번들러 – Turbopack 선택 이유

### Turbopack의 역할

Turbopack은 개발 환경 전용 번들러로 사용한다.

- 빠른 HMR
- 변경된 모듈만 즉시 재빌드
- 대규모 코드베이스에서도 일관된 속도 유지

### Turbopack을 개발 환경에만 사용하는 이유

개발 환경에서는 빠른 피드백 루프가 가장 중요하다.

Turbopack은 Next.js의 개발 서버에서 사용되는 번들러로, 변경된 모듈만 즉시 반영하는 구조를 통해

대규모 코드베이스에서도 일관된 반응성을 제공한다.

본 프로젝트에서는 Turbopack을 **개발 환경 전용 도구**로 사용한다.

Turbopack이 아직 프로덕션 빌드 측면에서는 실험적인 성격을 가지기 때문이며,

개발 속도와 운영 안정성을 분리해 관리하기 위한 구조적 판단이다.

### 4.1.5 프로덕션 번들러 – Webpack 선정 이유

### 비교 대상

| 항목 | Webpack | Turbopack (prod) | Vite (Rollup) |
| --- | --- | --- | --- |
| 안정성 | 매우 높음 | 실험적 | 높음 |
| Next.js 공식 지원 | ✅ | 부분 | ❌ |
| SSR / RSC 호환성 | 완전 | 진행 중 | 제한 |
| 운영 레퍼런스 | 풍부 | 적음 | 제한적 |

Webpack은 Next.js의 기본 프로덕션 번들러로

- 이미지 최적화
- 코드 스플리팅
- 서버 액션 및 미들웨어 처리

등 Next.js 핵심 기능과 완전히 통합되어 있다. 이는 운영 환경에서의 **예측 가능성**을 높여준다.

**Next.js가 검증된 경로로 제공하는 빌드 결과를 그대로 신뢰**하는 방향을 택하였다

### 4.1.6 Vite를 최종적으로 사용하지 않은 이유

Vite는

- 빠른 개발 서버
- 단순한 설정
- CSR 기반 SPA에서 사실상 표준

이라는 장점을 가진 훌륭한 도구이다. 그러나 본 프로젝트는

- Next.js App Router
- React Server Component
- SSR / SSG / ISR 혼합 전략

을 사용하며, 이 경우 Vite는 공식 통합이 부족하고 빌드 파이프라인이 이중화될 가능성이 있으며 문제 발생 시 레퍼런스가 제한적이다. 따라서 Vite의 단점을 이유로 배제했다기보다,

Next.js의 공식 빌드 파이프라인을 따르는 것이 더 합리적이라고 판단하였다.

# 5. 패키지 매니저

## 5.1 Package Manager 선정 이유

### 5.1.1 비교 대상

| 항목 | npm | Yarn (Berry) | pnpm |
| --- | --- | --- | --- |
| 기본 제공 여부 | Node.js 기본 | 별도 설치 | 별도 설치 |
| 의존성 설치 방식 | 중복 설치 | Plug’n’Play | 글로벌 스토어 + 링크 |
| 디스크 사용량 | 많음 | 매우 적음 | 매우 적음 |
| 설치 속도 | 보통 | 빠름 | 빠름 |
| node_modules 사용 | ✅ | ❌ (PnP) | ✅ |
| 설정/학습 비용 | 낮음 | 높음 | 낮음 |
| Next.js 호환성 | 매우 높음 | 일부 이슈 사례 | 매우 높음 |
| 대규모 프로젝트 적합성 | 보통 | 높음 | 높음 |

### 5.1.2 pnpm

### 1️⃣ 디스크 효율성과 의존성 관리 방식

pnpm은 모든 패키지를 **글로벌 스토어에 한 번만 저장**하고, 프로젝트에서는 하드 링크를 통해 이를 참조한다.

이 방식은

중복 의존성 설치 방지

- 디스크 사용량 감소
- 의존성 구조의 명확성

을 동시에 제공한다.

Next.js 프로젝트처럼 의존성 수가 많은 환경에서 장기적으로 관리 비용을 줄이는 데 유리하다.

### 2️⃣ Next.js 및 툴체인과의 높은 호환성

pnpm은 Next.js 공식 문서에서 지원되며, SWC, Turbopack, Webpack과 안정적으로 연동된다.

또한 lockfile(`pnpm-lock.yaml`)을 통해 로컬, CI, 운영 환경 간 설치 결과의 차이를 최소화할 수 있다.

이는 팀 협업과 장기적인 유지보수 관점에서 중요한 요소이다.

### 5.1.3 npm과 Yarn Berry를 중심으로 보지 않은 이유

npm은 범용적이고 안정적인 도구이지만, 의존성 수가 많아질수록 중복 설치로 인한 비용이 증가한다.

Yarn Berry(PnP)는 이론적으로 효율적이지만, `node_modules`가 없는 구조로 인해 일부 라이브러리 및 도구와의 마찰이 발생할 수 있다.

본 프로젝트에서는 새로운 패키지 관리 모델을 도입하는 것보다,

Next.js 생태계와 자연스럽게 맞물리는 구조를 우선하였다.

# <mark> 6. PWA 구성 및 Service Worker 전략 </mark>

## 6.1 PWA 도입 배경

본 프로젝트는 모바일 사용 비중이 높으며, 웹 환경에서도 앱과 유사한 사용 경험을 제공하는 것을 목표로 한다.

이에 따라 설치 부담 없이 접근 가능하고, 반복 방문 시 성능 이점을 제공할 수 있는 플랫폼 전략으로

PWA를 도입하였다.

## 6.2 PWA 적용 범위 정의

PWA는 다음과 같은 범위로 한정하여 적용한다.

- 홈 화면 설치(Add to Home Screen)
- 기본 앱 메타데이터 제공(Web App Manifest)
- 정적 리소스 캐싱을 통한 초기 로딩 성능 개선

채팅, 추천, 레포트와 같이 실시간 상호작용이 핵심인 서비스 특성상, 완전한 오프라인 동작이나 데이터 동기화는 목표로 하지 않는다.

이를 통해 PWA 적용으로 인한 복잡도를 최소화하고, 서비스 성격에 맞는 실질적인 이점에 집중한다.

## 6.3 Service Worker의 역할 정의

Service Worker는 애플리케이션의 핵심 로직이 아닌, 성능을 보조하는 인프라 계층으로 사용한다.

주요 역할은 다음과 같다.

- 정적 리소스 캐싱
- 반복 방문 시 초기 로딩 속도 개선
- 네트워크 불안정 환경에서의 최소한의 안정성 확보

API 응답 데이터의 캐싱이나 동기화 책임은 Service Worker가 아닌

- 클라이언트 데이터 계층(TanStack Query)에 위임한다.

이를 통해 데이터 일관성과 상태 관리 책임을 명확히 분리한다.

## 6.4 캐싱 전략 설계

### 캐싱 대상 분리 원칙

| 리소스 유형 | 처리 전략 |
| --- | --- |
| HTML 문서 | Network First |
| JS / CSS 번들 | Stale-While-Revalidate |
| 이미지 / 아이콘 / 폰트 | Cache First |
| API 요청 | Network Only |

### 전략 설계 의도

- **HTML 문서 (Network First)**
    
    SSR 기반 구조를 유지하기 위해 항상 최신 응답을 우선하며, 네트워크 실패 시에만 캐시를 fallback으로 사용한다.
    
- **JS / CSS 번들 (Stale-While-Revalidate)**
    
    빠른 초기 응답을 제공하면서, 백그라운드에서 최신 리소스를 갱신하여 UX와 최신성의 균형을 유지한다.
    
- **정적 리소스 (Cache First)**
    
    변경 가능성이 낮은 자산은 캐시 우선으로 처리하여 네트워크 비용과 응답 시간을 최소화한다.
    
- **API 요청 (Network Only)**
    
    실시간성이 중요한 데이터는 캐시하지 않고 서버를 단일 진실 공급원으로 유지한다.
    

# 7. Architecture – Feature-Sliced Design(FSD)

## 7.1 아키텍처 적용 배경

버전에 따라 기능이 빠르게 확장되는 서비스 특성상 다음과 같은 구조적 문제를 예방할 필요가 있었다.

- 기능 단위 책임이 불명확한 폴더 구조로 인한 유지보수 비용 증가
- 전역 상태/유틸리티의 무분별한 확장으로 인한 결합도 상승
- 기능 간 의존성 증가로 인한 변경 영향 범위 확대
- 규모 확장 시 구조 일관성 붕괴 가능성

이에 따라 기능(feature) 중심으로 책임을 분리하고, 의존성 흐름을 예측 가능하게 유지할 수 있는 구조가 필요하다고 판단하였다.

---

## 7.2 FSD 개요

Feature-Sliced Design(FSD)은 애플리케이션을 기능과 책임 단위로 분해하고, 레이어 간 단방향 의존성 규칙을 통해 구조를 통제하는 아키텍처이다.

- 하위 레이어는 상위 레이어를 참조할 수 없다.
- 상위 레이어는 하위 레이어를 조합하여 기능/화면을 구성한다.

이를 통해 기능 확장 시에도 의존성 흐름을 예측 가능하게 유지한다.

## 7.3 FSD 레이어 구성 (Next.js App Router 환경 정리)

Next.js(App Router)에서는 라우팅 엔트리가 `app/` 디렉토리에 존재하므로, FSD의 “라우트 단위 조합” 레이어는 개념적으로 `routes`(또는 `screens`)로 정의한다.

| 레이어 | 역할 |
| --- | --- |
| `app` | 애플리케이션 초기화/전역 설정(Provider, 전역 스타일 등) |
| `routes` | 라우트 단위 화면 조합(페이지 구성, 위젯 배치) |
| `widgets` | 복합 UI 블록(여러 feature/entity 조합) |
| `features` | 사용자 상호작용/시나리오(입력, 버튼 액션, mutation 중심) |
| `entities` | 핵심 도메인(타입/모델, 조회 중심 query, 도메인 UI) |
| `shared` | 도메인 무관 공통(primitive UI, lib, infra 설정, 유틸) |

App Router의 Server/Client 실행 환경 경계가 존재하므로, 레이어 규칙과 별개로 다음 원칙을 추가한다.

- 서버 전용 로직은 `.server.ts` 또는 `server/`에 위치한다.
- 클라이언트 전용 로직은 `.client.ts` 또는 `client/`에 위치한다.
- Server Component에서 import 가능한 모듈 범위를 명확히 제한한다.

### 비즈니스 로직 위치의 명확성

- 화면 조합 → `routes`, `widgets`
- 사용자 행동 및 mutation → `features`
- 도메인 모델 및 조회(query) → `entities`
- 범용/인프라 코드 → `shared`

이를 통해 로직의 위치가 명확해지고 구조 일관성이 유지된다.

### 상태 관리 전략과의 결합

- `entities`: 서버 상태 조회(query) 및 도메인 모델
- `features`: 사용자 행동(mutation) 중심 로직
- `shared`: TanStack Query 클라이언트 설정, fetcher, 공통 처리
- Zustand는 서버 상태를 저장하지 않고, “클라이언트 전용 상태”에 한정한다
